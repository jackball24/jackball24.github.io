<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux简单命令入门</title>
      <link href="/loki/Linux-orders/"/>
      <url>/loki/Linux-orders/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><div class='additional-content-after-post'><div style="background-color: rgba(0, 0, 0, 0);width:100% ">最近写操作系统的实验用到了很多Linux的操作，想着虽然提前接触过Linux，但是好像并没有做过系统的归纳总结，正好借着这机会来重温一下</div></div><p><strong>仅查看命令请跳转——&gt;<a href="http://shikongl0k1.top/loki/Linux-orders/#4-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4">4.基础命令</a></strong></p><h3 id="1-Linux之灵魂"><a href="#1-Linux之灵魂" class="headerlink" title="1.Linux之灵魂"></a>1.Linux之灵魂</h3><p><strong>Linux</strong>作为一个开源且免费的操作系统，深受极客喜爱，它稳定且高效、安全且自由，在服务器领域运用广泛。</p><p>初次使用Linux操作系统，你会发现在这里万物皆为文件，没有Windows那复杂的系统构造，频繁的版本更新，以及修改系统文件时权限不够的问题；还能支持一些Windows和MacOS所不能的服务。Linux，yes！</p><p>目前市面上较知名的发行版有：<strong>Ubuntu、RedHat、CentOS、Debian、Fedora、Arch Linux</strong>等，还有一些常见的比如<strong>kali</strong>（基于Debian的发行版，常用于网络渗透测试、破解密码、逆向工程等，深受hacker喜爱）。</p><p>而Linux之灵魂，便是<strong>terminal</strong>和<strong>command</strong>（终端和命令），用户在终端输入命令，然后<strong>shell</strong>（命令解释器）翻译并执行指令，将结果返还给终端（有点像windows的cmd）。</p><p>Linux的安装十分简单，一般推荐刚入坑的萌新使用的，是一个叫Ubuntu（乌班图）的Linux发行版，第一次一般会推荐使用<a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">VMware Workstation Pro</a>+官网下载系统镜像<a href="https://ubuntu.com/download/desktop">Download Ubuntu Desktop | Download | Ubuntu</a>，当然这可能会很慢，所以也可以去清华镜像站<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a>或者你邮的镜像站<a href="http://mirrors.njupt.edu.cn/">南京邮电大学开源软件镜像站 | Njupt Open Source Mirror</a>（东西少但下载还挺快的）这类的国内镜像网站下载所需要的ISO镜像；当然，完整的安装步骤较多，建议找一篇较新的教程，跟着一步步走。</p><p>按照一些教程成功安装虚拟机之后便会进入一个桌面，紫红底，上面有豹猫（20.04）或者水母（22.04）之类的图案。</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/2204dedsktop.jpg#pic_right" alt="22.04desktop"></p><p>这是带有图形化界面的Ubuntu，而他的本体只是那一个终端命令行以及所使用的Ubuntu server，也就是说：所有你能用图形化界面完成的事情，<strong>命令行</strong>都能完成（早期的系统都是先有命令行，再在此基础上开发适合大众使用的图形化界面）。</p><p>笔者目前使用的较多的是wsl2-kali（windows的linux子系统-kali版），所有的操作均由命令完成（VM虚拟机占空间大，wsl对我来说更轻便）。</p><h3 id="2-VM虚拟机的小技巧"><a href="#2-VM虚拟机的小技巧" class="headerlink" title="2.VM虚拟机的小技巧"></a>2.VM虚拟机的小技巧</h3><h4 id="2-1快照的使用"><a href="#2-1快照的使用" class="headerlink" title="2.1快照的使用"></a>2.1快照的使用</h4><p>在主机中，如果不小心把C盘重要文件删了，电脑扑街了咋办？重装&#x2F;重买&#x2F;花大把时间用工具恢复。而在虚拟机中，你仿佛拥有了时间宝石，可以随时回到你创建快照的那个时间，那个样子。</p><p>这一切的实现只需要两步</p><p>1.<img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut1.png#pic_center" alt="image-20230511204330059"></p><p>2.在未来想要回到刚才那个时间点的时候点击“恢复到快照”</p><h4 id="2-2克隆和删除"><a href="#2-2克隆和删除" class="headerlink" title="2.2克隆和删除"></a>2.2克隆和删除</h4><p>可以在左侧右击</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut2.png#pic_center" alt="image-20230511204821285"></p><h4 id="2-3VMtools"><a href="#2-3VMtools" class="headerlink" title="2.3VMtools"></a>2.3VMtools</h4><p>没法在主机和虚拟机之间复制粘贴？我想直接把文件拽进虚拟机？安装一个vmware tools通通搞定</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut3.png#pic_center" alt="image-20230511205255605"></p><h3 id="3-常用的目录"><a href="#3-常用的目录" class="headerlink" title="3.常用的目录"></a>3.常用的目录</h3><ul><li><code>/</code>   根目录，可以想象成数据结构里面的根结点</li><li><code>/root</code>  超级管理员的主目录</li><li><code>/home</code>  普通用户主目录</li><li><code>/bin</code>  bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</li><li><code>/boot</code>  这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><code>/lib</code>  lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。</li><li><code>/usr</code>   unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</li><li><code>/var</code>  variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li><code>/usr/bin</code>  系统用户使用的应用程序。</li></ul><h3 id="4-基础命令"><a href="#4-基础命令" class="headerlink" title="4.基础命令"></a>4.基础命令</h3><p>这里不会把命令列得很全，主要还是一些最简单的操作。</p><h4 id="4-1实际场景"><a href="#4-1实际场景" class="headerlink" title="4.1实际场景"></a>4.1实际场景</h4><p>桌面右键后&#x2F;直接找到terminal，进入终端，你可以直接使用普通用户操作，当然，你也可以使用<strong>sudo -i</strong>或<strong>sudo</strong>或<strong>su</strong>等命令进入root用户</p><p>三个命令有一些区别：</p><p>sudo : 暂时切换到超级用户模式以执行超级用户权限；</p><p>su ： 切换到某某用户模式，提示输入密码时该密码为切换后账户的密码，默认为root账户；</p><p>sudo -i: 为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。提示输入密码时该密码为当前账户的密码。没有时间限制</p><h5 id="1-切换用户"><a href="#1-切换用户" class="headerlink" title="1.切换用户"></a>1.切换用户</h5><pre><code class="shell">su</code></pre><p>然后输入密码（一般不显示，输完敲回车即可）</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut26.png" alt="image-20230512220257556"></p><p>然后我们想干嘛呢，在windows中我们一般是先看到一堆文件，然后选择进入哪一个，那么在linux里，我们只使用命令行要怎么做？</p><h5 id="2-查看当前目录下的文件"><a href="#2-查看当前目录下的文件" class="headerlink" title="2.查看当前目录下的文件"></a>2.查看当前目录下的文件</h5><pre><code class="shell">ls或者:ll</code></pre><p>查看当前目录的绝对路径</p><pre><code>pwd</code></pre><h5 id="3-进入文件夹"><a href="#3-进入文件夹" class="headerlink" title="3.进入文件夹"></a>3.进入文件夹</h5><pre><code class="shell">cd 文件名</code></pre><p>去想要去的目录（可以有多级，用“&#x2F;”分开）</p><h5 id="4-ls再次查看"><a href="#4-ls再次查看" class="headerlink" title="4.ls再次查看"></a>4.ls再次查看</h5><p>每进入一层目录，你可能不知道里面有哪些文件</p><h5 id="5-进入上一级文件夹"><a href="#5-进入上一级文件夹" class="headerlink" title="5.进入上一级文件夹"></a>5.进入上一级文件夹</h5><p>如果想返回上一层，则使用</p><pre><code class="shell">cd ..</code></pre><p>（同样可以有多级，用“&#x2F;”分开）</p><p>你会得到类似这样的结果：</p><p><strong>先回到<code>/</code>根目录，再向下级探索：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut25.png" alt="image-20230512220240679"></p><p><strong>往上回溯：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut5.png" alt="image-20230512202440177"></p><h5 id="6-新建文件夹"><a href="#6-新建文件夹" class="headerlink" title="6.新建文件夹"></a>6.新建文件夹</h5><pre><code class="shell">mkdir 文件夹名</code></pre><p>新建空文件（非文件夹）</p><pre><code class="shell">touch 文件名</code></pre><h5 id="7-删除文件夹-x2F-文件（用rmdir-能删空目录）："><a href="#7-删除文件夹-x2F-文件（用rmdir-能删空目录）：" class="headerlink" title="7.删除文件夹&#x2F;文件（用rmdir 能删空目录）："></a>7.删除文件夹&#x2F;文件（用<strong>rmdir</strong> 能删空目录）：</h5><pre><code class="shell">rm -rf 文件名</code></pre><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut6.png" alt="image-20230512203434690"></p><p>我创建了“学习资料”文件夹，又删除了file和new文件夹</p><h5 id="8-读文件"><a href="#8-读文件" class="headerlink" title="8.读文件"></a>8.读文件</h5><p>ls之后发现在学习资料里有个文件，</p><p>我想看一下（只读）secret.txt里到底有什么？</p><pre><code class="shell">cat 文件名</code></pre><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut7.png" alt="image-20230512204656750"></p><p>可以看到secret.txt写的东西（</p><div class='additional-content-after-post'><div style="background-color: rgba(0, 0, 0, 0);width:100% "> 温馨提示：你输入过的所有命令都可以使用↑和↓键来翻阅（省去了长命令的二次输入）</div></div><h4 id="4-2-vi-x2F-vim操作（编辑文件）"><a href="#4-2-vi-x2F-vim操作（编辑文件）" class="headerlink" title="4.2 vi&#x2F;vim操作（编辑文件）"></a>4.2 vi&#x2F;vim操作（编辑文件）</h4><p>vim为linux自带vi的升级版，两者你都可以看成是windows里的记事本，只不过更“高级”一点。</p><h5 id="1-编辑文件"><a href="#1-编辑文件" class="headerlink" title="1.编辑文件"></a>1.编辑文件</h5><pre><code class="c">vim 文件名</code></pre><p>我这里vim了一个hello.c文件</p><p>之后进入一个奇怪的界面，好像还动不了（这是一般模式，可以使用方向键移动光标）</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut23.png" alt="image-20230512220105587"></p><h5 id="2-按下-i-进入插入模式（你可以编辑了）"><a href="#2-按下-i-进入插入模式（你可以编辑了）" class="headerlink" title="2.按下 i 进入插入模式（你可以编辑了）"></a>2.按下 i 进入插入模式（你可以编辑了）</h5><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut13.png" alt="image-20230512213050224"></p><h5 id="3-保存并退出"><a href="#3-保存并退出" class="headerlink" title="3.保存并退出"></a>3.保存并退出</h5><p>写完后，按下键盘左上角ESC退出插入模式，接着输入</p><pre><code>:wq</code></pre><p>然后就可以看到，hello.c有刚才的内容了</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut22.png" alt="image-20230512220045923"></p><p>我要安装gcc编译它？</p><pre><code>sudo apt install gcc</code></pre><p>（root账户就不需要前面的sudo）</p><p>然后，就是熟悉的</p><pre><code class="shell">gcc hello.c -o hello.out</code></pre><pre><code class="shell">./hello.out</code></pre><h5 id="4-更多快捷键"><a href="#4-更多快捷键" class="headerlink" title="4.更多快捷键"></a>4.更多快捷键</h5><p>一般模式下的撤销</p><p><code>u键</code></p><p>拷贝本行</p><p><code>yy</code></p><p>删除本行</p><p><code>dd</code></p><p>格式化全部代码</p><p><code>gg=G</code></p><p>gg为跳转到第一行，G为最后一行</p><p>……</p><h4 id="4-3其他命令"><a href="#4-3其他命令" class="headerlink" title="4.3其他命令"></a>4.3其他命令</h4><h5 id="1-查看当前ip（windows是ipconfig）"><a href="#1-查看当前ip（windows是ipconfig）" class="headerlink" title="1.查看当前ip（windows是ipconfig）"></a>1.查看当前ip（windows是ipconfig）</h5><pre><code class="shell">ifconfig</code></pre><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut21.png" alt="image-20230512220022168"></p><h5 id="2-用一下计网提到过的ping命令"><a href="#2-用一下计网提到过的ping命令" class="headerlink" title="2.用一下计网提到过的ping命令"></a>2.用一下计网提到过的ping命令</h5><pre><code class="shell">ping [ip]</code></pre><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/cut20.png" alt="image-20230512215954218"></p><p>显然ping得通（因为是本地）</p><h5 id="3-关机"><a href="#3-关机" class="headerlink" title="3.关机"></a>3.关机</h5><pre><code class="shell">shutdown</code></pre><h5 id="4-重启"><a href="#4-重启" class="headerlink" title="4.重启"></a>4.重启</h5><pre><code>reboot</code></pre><h5 id="5-退出当前账户-x2F-终端"><a href="#5-退出当前账户-x2F-终端" class="headerlink" title="5.退出当前账户&#x2F;终端"></a>5.退出当前账户&#x2F;终端</h5><pre><code>exit</code></pre><h5 id="6-改变文件的权限"><a href="#6-改变文件的权限" class="headerlink" title="6.改变文件的权限"></a>6.改变文件的权限</h5><pre><code class="shell">chmod -R 777 *</code></pre><p>比较懒的一种用法，chmod是改变权限命令，-R修改应到目录下所有文件和子目录，777，三种用户权限都为7（读4+写2+执行1），*则是通配符，其他用法可自行查阅</p><h5 id="7-服务管理"><a href="#7-服务管理" class="headerlink" title="7.服务管理"></a>7.服务管理</h5><pre><code>1.systemctl ……2.service ……</code></pre><h5 id="8-进程"><a href="#8-进程" class="headerlink" title="8.进程"></a>8.进程</h5><pre><code>ps -a      //当前终端所有进程信息ps -ups -xps -elps -ef等</code></pre><p>终止进程</p><pre><code>kill -选项数字 进程名</code></pre><p>……</p><h3 id="5-换源以及安装输入法等操作"><a href="#5-换源以及安装输入法等操作" class="headerlink" title="5.换源以及安装输入法等操作"></a>5.换源以及安装输入法等操作</h3><p>我们会发现在使用apt下载东西的时候速度很慢，还总是卡住，那是因为原来的源在国内是很慢的，就像前面下载官方镜像一样，我们需要换成国内的镜像源……未完待续</p><h3 id="引用及参考"><a href="#引用及参考" class="headerlink" title="引用及参考"></a>引用及参考</h3><p>该文章部分内容参考以下网站&#x2F;博客：</p><ul><li><p><a href="https://www.runoob.com/linux">https://www.runoob.com/linux</a></p></li><li><p><a href="https://www.yumoyumo.top/295.html">Linux入门到实践 – 羽墨的个人博客 (yumoyumo.top)</a></p></li></ul><p>笔者才疏学浅，有不当的地方还望大佬交流指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的使用</title>
      <link href="/loki/Git-use/"/>
      <url>/loki/Git-use/</url>
      
        <content type="html"><![CDATA[<p>代码的对比以及版本管理</p><p>——回溯</p>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收集一些好的博文规范</title>
      <link href="/loki/fansyBlog/"/>
      <url>/loki/fansyBlog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora &amp; Picgo &amp; GitXXX 图床使用</title>
      <link href="/loki/Typora-Picgo-GitXXX-Use/"/>
      <url>/loki/Typora-Picgo-GitXXX-Use/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工具&amp;环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Code</title>
      <link href="/loki/My-Code/"/>
      <url>/loki/My-Code/</url>
      
        <content type="html"><![CDATA[<blockquote><p>高中到大二之前写过一些简单的有一点用处的代码（多指实验报告）</p></blockquote><p>目前为css代码样式测试，真·useful code还没整理好。</p><h3 id="1-Kinds-of-sort"><a href="#1-Kinds-of-sort" class="headerlink" title="1.Kinds of sort"></a>1.Kinds of sort</h3><p><del>其中有些奇奇怪怪的函数命名[&#x2F;滑稽]</del></p><table width=100% bgcolor="#eef7fa" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #428bca" ><tr>  <th align="left" style="color: black">C++代码：</th></tr></table><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;void choose(int *a);//选择 void stick(int *a);//插排 void bubbling(int *a);//冒泡 void fast(int left,int right,int *a);//快排 void shell(int *a);//希尔 void merge(int *a,int l,int r);//归并 void heap_sort(int *a,int len);//堆排 void gaynumber(int *a,int n);//基数(正数情况)void radixsort(int *a,int n);//基数(加强) void bucket(int *a);//桶排 void odd_even(int *a);//砖排(奇偶) void heap(int a[],int start,int length);void change(int *a,int *b);int main()&#123;    int i,a[100];     srand(time(0));    for(i=0;i&lt;100;i++)&#123;        a[i]=pow(-1,rand()%2+1)*(rand()%101);        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;//输出-100~100之间的随机数，可能重复     cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;排序后：&quot;&lt;&lt;endl&lt;&lt;endl;    //sort(a,a+100);//内置快速排序     //choose(a);    //stick(a);     //bubbling(a);    //fast(0,99,a);    shell(a);    //merge(a,0,99);     //heap_sort(a,100);    //gaynumber(a,100);    //radixsort(a,100);    //bucket(a);    //odd_even(a);        for(i=0;i&lt;100;i++)&#123;        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;&#125;void change(int *a,int *b)&#123;//可以直接用swap代替     int t=*a;    *a=*b;    *b=t;&#125;void choose(int *a)&#123;    int i,k,j;    for(j=0;j&lt;99;j++)&#123;        k=j;        i=j+1;        while(i&lt;=99)&#123;        a[i]&lt;a[k]?k=i:i++;        &#125;        if(k!=j)            change(&amp;a[j],&amp;a[k]);    &#125;&#125;void stick(int *a)&#123;    int t,i,j;    for (i=0;i&lt;99;i++)    &#123;        t=a[i+1];        for(j=i;j&gt;=0&amp;&amp;a[j]&gt;t;j--)        &#123;            a[j+1]=a[j];        &#125;        a[j+1]=t;    &#125;&#125;void bubbling(int *a)&#123;    for(int i=0;i&lt;99;i++)&#123;        for(int j=99;j&gt;i;j--)&#123;            if(a[j]&lt;a[j-1])                change(&amp;a[j],&amp;a[j-1]);        &#125;    &#125;    &#125;void fast(int left,int right,int *a)&#123;    if(left&gt;=right)return;    int i=left,j=right,base=a[left];    while(i&lt;j)&#123;        while(a[j]&gt;=base &amp;&amp; i&lt;j)j--;        while(a[i]&lt;=base &amp;&amp; i&lt;j)i++;        if(i&lt;j)            change(&amp;a[i],&amp;a[j]);    &#125;      a[left]=a[i];    a[i]=base;    fast(left,i-1,a);    fast(i+1,right,a);&#125;void shell(int *a)&#123;    int length=100,gap=1;    while(gap&lt;length)&#123;        gap=gap*3+1;    &#125;    while(gap&gt;0)&#123;        for(int i=gap;i&lt;length;i++)&#123;            int tmp=a[i],j=i-gap;            //跨区间排序            while(j&gt;=0&amp;&amp;a[j]&gt;tmp)&#123;                a[j+gap]=a[j];                j-=gap;            &#125;            a[j+gap]=tmp;        &#125;        gap=gap/3;    &#125;&#125;void merge(int *a,int l,int r)&#123;    if(l==r)return;//递归退出条件    int mid=l+r&gt;&gt;1;//中间值mid    merge(a,l,mid),merge(a,mid+1,r);    //合并    int k=l,i=l,j=mid+1,temp[1000];    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;        if(a[i]&lt;=a[j])//左大于右             temp[k++]=a[i++];        else             temp[k++]=a[j++];//两段相比小的放入到临时数组里面    &#125;    //如果一个数组已经遍历完了，另外一个数组剩余一个数，这个数一定是最大的。    while(i&lt;=mid)        temp[k++]=a[i++];    while(j&lt;=r)        temp[k++]=a[j++];     for(i=0;i&lt;=r;i++)&#123;         a[i]=temp[i];     &#125;&#125;void heap_sort(int* a,int len)&#123;//可以len=sizeof(a)/sizeof(int)        //初始化建堆：        for(int i=len/2-1;i&gt;=0;--i)//1.创建堆make_heap, 从最后一个非叶子节点开始                heap(a,i,len);         //排序重建堆             for(int i=len-1;i&gt;=0;i--)&#123;//2. 堆排序, 此时 [1, len] 为一个堆                swap(a[0],a[i]);           //堆顶元素和末尾元素进行交换                heap(a,0,i);        // 对顶点进行一次堆排序// 此时堆末元素已经有序(存的是最大值),        &#125;// 剩余堆的范围变成了 [1, len-1], 但由于上一步的交换可能破坏堆的性质, 故要进行调整&#125;void heap(int a[],int start,int length)//判断是不是符合大根堆&#123;        int left=2*start+1,right=2*start+2,max=start;        if(left&lt;length&amp;&amp;a[left]&gt;a[max])//left &lt;= len 防止节点不存在                max=left;        if(right&lt;length&amp;&amp;a[right]&gt;a[max])//a[right] &gt; a[max] 判断是不是根节点最大(因为你每个子树都要符合大根堆的性质啊)                max=right;        if(max!=start)&#123;                swap(a[max],a[start]);//交换节点                heap(a,max,length);//从当交换后前节点开始, 调整下面的堆        &#125;&#125;//这里的 max 是当前 father 的某一个儿子, 而不是 father 自身,　因为交换后 father 本来就是有序的.void gaynumber(int *a,int n) //基数排序&#123;    int d=1; //保存最大的位数    int p=10;    for(int i=0;i&lt;n;++i)    &#123;        while(a[i]&gt;=p)        &#123;            p*=10;            ++d;        &#125;    &#125;    int tmp[n],radix=1,i,j,k;    int count[10]; //计数器    for(i=1;i&lt;=d;i++) //进行d次排序    &#123;        for(j=0;j&lt;10;j++)            count[j]=0; //每次分配前清空计数器        for(j=0;j&lt;n;j++)        &#123;            k=(a[j]/radix)%10; //统计每个桶中的记录数            count[k]++;        &#125;        for(j=1;j&lt;10;j++)            count[j]=count[j-1]+count[j]; //将tmp中的位置依次分配给每个桶        for(j=n-1;j&gt;=0;j--) //将所有桶中记录依次收集到tmp中        &#123;            k=(a[j]/radix)%10;            tmp[count[k]-1]=a[j];            count[k]--;        &#125;        for(j=0;j&lt;n;j++) //将临时数组的内容复制到a中            a[j]=tmp[j];        radix=radix*10;    &#125;&#125;void radixsort(int *a,int n)&#123;      int tank[20][100];         //20个桶, tank[x][i]表示当前位是x的第i个数，这里tank[x][0]表示tank[x]这个数组有多少个元素,故存数据时从tank[x][1]开始存    int k=1,d=1;        //k是最大位数，d是当前位的权重，即1, 10, 100.....        //计算最大位数, 公式 k = (int)log10(x) + 1，注意x要大于0    for(int i=0;i&lt;n;i++)         if(a[i])        //非零时, 计算 |a[i]| 的位数            k=max((int)log10(abs(a[i]))+1,k);        while(k--)&#123;            //循环k次        memset(tank,0,sizeof(tank));        //每次循环先把tank清零                for(int i=0;i&lt;n;i++)&#123;        //枚举n个数            int x=a[i]/d%10+10; //得到当前位的值x（记得要加10）            tank[x][++tank[x][0]]=a[i];     //放到第x个桶里面，注意是++tank[x][0]        &#125;                int cnt=0;        for(int i=0;i&lt;20;i++)       //枚举20个桶            //依次拿出每个桶里面的值[1, tank[i][0]], 注意取出顺序和放入顺序是一样的（类似队列,先进先出），故基数排序稳定            for(int j=1;j&lt;=tank[i][0];j++)                   a[cnt++]=tank[i][j];        //回收        d*=10;        //权重 * 10    &#125; &#125;void bucket(int *a)&#123;    int b[201]=&#123;0&#125;,j=0,s;    for(int i=0;i&lt;100;i++)&#123;        b[a[i]+100]++;    &#125;    for(int i=0;i&lt;=200;i++)&#123;        if(b[i]!=0)            for(s=0;s&lt;b[i];s++)                a[j++]=i-100;    &#125;&#125; void odd_even(int *a)&#123;    int sort=0,i;    while(!sort)&#123;      sort=1;      for(i=1;i&lt;100;i+=2)&#123;         if(a[i]&gt;a[i+1])&#123;            swap(a[i],a[i+1]);            sort=0;         &#125;      &#125;      for(i=0;i&lt;99;i+=2)&#123;         if(a[i]&gt;a[i+1])&#123;            swap(a[i],a[i+1]);            sort=0;         &#125;      &#125;   &#125;&#125;</code></pre><table width=100% bgcolor="#eff8f0" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #5cb85c" ><!--<tr>  <th align="left" style="color: black">Python代码： </th></tr><tr>-->   <td align="left" style="color: black">       Python代码：    <br/></br/> &emsp;&emsp;  巴拉巴拉巴拉    巴拉巴拉</td></tr></table><table width=100% bgcolor="#fcf1f2" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #d9534f" ><tr>  <th align="left" style="color: black">Java代码：</th></tr></table><table width=100% bgcolor="#fdf8ea" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #f0ad4e" ><tr>  <th align="left" style="color: black">快排、合并：</th></tr></table><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std; template &lt;class T&gt;class SortableList&#123;    public:        int n;        T l[100];//输入的数组值        T a[100];//实际排序对象        SortableList(int max)        &#123;            n = max;        &#125;        void MergeSort();        void QuickSort();        void Input();        void Init();        void Output();        void Select(int k) &#123;              int j= Select(k,0,n-1,5);              cout&lt;&lt;&quot;第&quot;&lt;&lt;k&lt;&lt;&quot;小元素是：&quot;&lt;&lt; a[k-1]&lt;&lt; endl;       &#125;    private:        int PartitionPlus(int left, int right);        int Partition(int left, int right);        void Merge(int left, int mid, int right);        void MergeSort(int left, int right);        void QuickSort(int left, int right);        void InsertSort(int left, int right);        int Select(int k, int left, int right, int r);&#125;;template&lt;class T&gt;void SortableList&lt;T&gt;::Input()&#123;    for(int i = 0; i &lt; n; i++)        cin &gt;&gt; l[i];&#125;//Init()函数的作用是在两路合并排序结束后将序列恢复到初始序列//再进行快速排序template&lt;class T&gt;void SortableList&lt;T&gt;::Init()&#123;    for(int i = 0; i &lt; n; i++)        a[i] = l[i];&#125;template&lt;class T&gt;void SortableList&lt;T&gt;::Output()&#123;    for(int i = 0; i &lt; n; i++)        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl &lt;&lt; endl;&#125; //两路合并排序template&lt;class T&gt;void SortableList&lt;T&gt;::MergeSort()&#123;    MergeSort(0, n - 1);&#125;template&lt;class T&gt;void SortableList&lt;T&gt;::MergeSort(int left, int right)&#123;    if(left &lt; right)    &#123;        int mid = (left + right) / 2;        MergeSort(left, mid);        MergeSort(mid + 1, right);        Merge(left, mid, right);    &#125;&#125;template &lt;class T&gt;void SortableList&lt;T&gt;::Merge(int left, int mid, int right)&#123;    T* temp =new T[right - left + 1];    int i = left, j = mid + 1, k = 0;    while((i &lt;= mid)&amp;&amp;(j &lt;= right))        if(a[i] &lt;= a[j])            temp[k ++] = a[i ++];        else            temp[k ++] = a[j ++];    while(i &lt;= mid)        temp[k ++] = a[i ++];    while(j &lt;= right)        temp[k ++] = a[j ++];    for(i = 0, k = left; k &lt;= right;)        a[k ++] = temp[i ++];&#125; //快速排序template &lt;class T&gt;int SortableList&lt;T&gt;::PartitionPlus(int left, int right)&#123;    srand((unsigned)time(NULL));    int i = rand() % (right - left) + left;    swap(a[i], a[left]);    return Partition(left, right);&#125;template &lt;class T&gt;int SortableList&lt;T&gt;::Partition(int left, int right)&#123;    int i = left, j = right + 1;    do&#123;        do i ++; while(a[i] &lt; a[left]);        do j --; while(a[j] &gt; a[left]);        if(i &lt; j) swap(a[i], a[j]);    &#125;while(i &lt; j);    swap(a[left], a[j]);    return j;&#125;template&lt;class T&gt;void SortableList&lt;T&gt;::QuickSort()&#123;    QuickSort(0, n - 1);&#125;template &lt;class T&gt;void SortableList&lt;T&gt;::QuickSort(int left, int right)&#123;    if(left &lt; right)    &#123;        int j = PartitionPlus(left, right);        QuickSort(left, j - 1);        QuickSort(j + 1, right);    &#125;&#125;template &lt;class T&gt;void SortableList&lt;T&gt;::InsertSort(int left, int right)&#123;       for (int i = left + 1; i &lt;= right; i++)       &#123;              int j = i;              int temp = a[i];              while (j&gt;left&amp;&amp;temp&lt;a[j- 1])              &#123;                     a[j]= a[j - 1];                     j--;              &#125;              a[i]= temp;       &#125;&#125;template &lt;class T&gt;int SortableList&lt;T&gt;::Select(int k, int left, int right, int r)&#123;  //每个分组r个元素，寻找第k小元素       int n = right - left + 1;       if (n &lt;= r)       &#123;              InsertSort(left, right);              return left + k - 1;  //返回第k小元素的下标       &#125;       for (int i = 1; i &lt;= n/ r; i++)       &#123;              InsertSort(left + (i - 1)*r, left + i*r - 1);               //二次取中规则求每组的中间值              swap(a[left+i-1],a[left+(i-1)*r+(int)ceil((double)r/2)-1]);                //每组中间值到子表前部集中存放       &#125;       int j = Select((int)ceil((double)n / r / 2), left, left + n / r - 1, r);        //二次中间值下标为j       swap(a[left], a[j]);  //二次中间值为枢纽元，并换至left处       j= Partition(left, right);  //对表（子表）进行分划操作       if (k == j - left + 1)  //返回第k小元素下标              return j;       else if (k &lt; j - left + 1)  //在左子表求第k小元素              return Select(k, left, j - 1, r);       else              return Select(k - (j - left + 1), j + 1, right, r);                //在右子表求第k-(j-left+1)小元素&#125; int main()&#123;    int m,k;    cout &lt;&lt; &quot;请输入元素个数n: &quot;&lt;&lt; endl;    cin &gt;&gt; m;    SortableList&lt;int&gt; List(m);    cout &lt;&lt; &quot;输入&quot; &lt;&lt; m &lt;&lt; &quot;个数字:&quot; &lt;&lt; endl;    List.Input();    List.Init();//得到初始状态    List.MergeSort();    cout &lt;&lt; endl &lt;&lt; &quot;两路合并排序后：&quot; &lt;&lt; endl;    List.Output();    List.Init();//恢复初始状态    cout &lt;&lt; &quot;快速排序后：&quot; &lt;&lt; endl;    List.QuickSort();    List.Output();    cout&lt;&lt;&quot;请输入查找第k小元素的k值：&quot;&lt;&lt; endl;       cin&gt;&gt;k;    List.Select(k);    for (int i=1;i&lt;=m;i++)        List.Select(i);    return 0; &#125;</code></pre><h3 id="2-广告位"><a href="#2-广告位" class="headerlink" title="2.广告位"></a>2.广告位</h3><p>目前为代码样式测试，真·useful code还没整理好</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/202305081430358.webp" alt="hackcode"></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时空の杂记</title>
      <link href="/loki/shikongMisc/"/>
      <url>/loki/shikongMisc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​许久没有写博客，先简单聊聊吧</p></blockquote><h3 id="1-浅学的一些东西"><a href="#1-浅学的一些东西" class="headerlink" title="1.浅学的一些东西"></a>1.浅学的一些东西</h3><p>因为大学前是没怎么接触电脑的小白（以前家里台式机，从小学开始接触过qq、4399等，在正经的计算机领域是green hand），做了不少没什么用的探索，虚拟机，网站的域名解析，使用集成环境搭建登录小网站，接触过一些密码，写过简单爬虫……&#x2F;&#x2F;（<strong>大一上</strong>干的闲事）| ubuntu gnome界面macos化、qq nonebot聊天机器人、vscode等许多工具的简单配置、从0开始学vim、学点ctfweb、参加hvv护网行动……&#x2F;&#x2F;<strong>大一下</strong>干的闲事</p><p>学习了一些有关linux的知识，接触了一下manjaro kde plasma，neo vim<del>（被dash board吸引）</del>，有关ctfweb学习摆了许久，在组里人push下接触了一些pop链、ssti、文件上传漏洞、ssrf、许多cve以及一些常规的绕过。回首过往，发现还是贪玩摆烂的时间多，玩机器人，玩服务器，玩AI画图、gpt，都没干什么正经的项目。</p><p>看到了<strong>X1r0z</strong>学弟的blog，五六年前接触webctf以及实战一些相关内容，可谓web一神。顺便膜一膜身边的dalao：huangx、picpo、winmt、sCh3n、NKID00……</p><p>有关java后端的知识要开始启动了，捡了很久还没有捡起来的算法已经烂掉了，安全与开发于我而言不可同时兼顾，所以当时准备从中选择一项深入。</p><p>UWP、git、python tensorflow、jupyter也才刚刚起步，之前也是部署了属于自己的网站（非本站），博客园已经许久不写内容，还有一个迟迟未建的靶场……就是觉得时间有些不太够，要学的东西真的还有很多，现在我仍然不具备个人的开发能力，在web安全方面的成就也很有限，感觉学的五花八门反而不如专精一项，好提前进厂打工。&#x2F;&#x2F;（<strong>大二上</strong></p><p>以上均是大一下至大二上的想法了，现在我的方向全部转移到开发方向上来。</p><p>寒假青训营学习了一些go的知识，现阶段要Java与算法兼顾，边学边写博客，学校的专业课也会整理在github等平台。就业这条路对于本科生本就困难，既然要去争取，就要找准方向实干，人的能力终究是有限的，我不可能在这短短时间内学习大佬们口中无所不谈的各方向知识，我目前所能做的，就是入门开发。</p><p><strong>大二下</strong>学期过半。然而好像不知道到底干了什么、学了什么。还是老老实实看点后端基础，刷点算法吧……</p><h3 id="2-后续blog的更新周期以及内容"><a href="#2-后续blog的更新周期以及内容" class="headerlink" title="2.后续blog的更新周期以及内容"></a>2.后续blog的更新周期以及内容</h3><p>主要讲述本人零基础学习后端的过程，以及一些必要的算法，坚持每周都要至少产出一篇，可能在学习过程中遇到好玩的或是有意义的也会分享。（flag立于2023.5.3周三）</p><p>还望大佬来交流指正</p><p>过去的已成为过去，就</p><pre><code class="shell">sudo rm -rf/*       ——&gt;reboot</code></pre><p>迎接未来吧！</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/202305081430363.webp" alt="wallhaven-x67dgo"></p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 札记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to shikong&#39;s blog</title>
      <link href="/loki/hello-world/"/>
      <url>/loki/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Here is jackball24&#x2F;shikong’s blog, it is started on <strong>2023&#x2F;3&#x2F;20</strong>.</p><p>I’m a programming beginner, and have lots of things to learn.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Create-a-new-page"><a href="#Create-a-new-page" class="headerlink" title="Create a new page"></a>Create a new page</h3><pre><code class="bash">$ hexo new page aboutme</code></pre><p>More info: <a href="https://hexo.io/docs/commands">Commands | Hexo</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
