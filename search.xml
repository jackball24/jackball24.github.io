<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux简单命令入门</title>
      <link href="/loki/Linux-orders/"/>
      <url>/loki/Linux-orders/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的使用</title>
      <link href="/loki/Git-use/"/>
      <url>/loki/Git-use/</url>
      
        <content type="html"><![CDATA[<p>代码的对比以及版本管理</p><p>——回溯</p>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收集一些好的博文规范</title>
      <link href="/loki/fansyBlog/"/>
      <url>/loki/fansyBlog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora &amp; Picgo &amp; GitXXX 图床使用</title>
      <link href="/loki/Typora-Picgo-GitXXX-Use/"/>
      <url>/loki/Typora-Picgo-GitXXX-Use/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工具&amp;环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Code</title>
      <link href="/loki/My-Code/"/>
      <url>/loki/My-Code/</url>
      
        <content type="html"><![CDATA[<blockquote><p>高中到大二之前写过一些简单的有一点用处的代码（多指实验报告）</p></blockquote><h3 id="1-Kinds-of-sort"><a href="#1-Kinds-of-sort" class="headerlink" title="1.Kinds of sort"></a>1.Kinds of sort</h3><p>其中有些奇奇怪怪的函数命名[&#x2F;滑稽]</p><table width=100% bgcolor="#eef7fa" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #428bca" ><tr>  <th align="left" style="color: black">C++代码：</th></tr></table><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;void choose(int *a);//选择 void stick(int *a);//插排 void bubbling(int *a);//冒泡 void fast(int left,int right,int *a);//快排 void shell(int *a);//希尔 void merge(int *a,int l,int r);//归并 void heap_sort(int *a,int len);//堆排 void gaynumber(int *a,int n);//基数(正数情况)void radixsort(int *a,int n);//基数(加强) void bucket(int *a);//桶排 void odd_even(int *a);//砖排(奇偶) void heap(int a[],int start,int length);void change(int *a,int *b);int main()&#123;    int i,a[100];     srand(time(0));    for(i=0;i&lt;100;i++)&#123;        a[i]=pow(-1,rand()%2+1)*(rand()%101);        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;//输出-100~100之间的随机数，可能重复     cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;排序后：&quot;&lt;&lt;endl&lt;&lt;endl;    //sort(a,a+100);//内置快速排序     //choose(a);    //stick(a);     //bubbling(a);    //fast(0,99,a);    shell(a);    //merge(a,0,99);     //heap_sort(a,100);    //gaynumber(a,100);    //radixsort(a,100);    //bucket(a);    //odd_even(a);        for(i=0;i&lt;100;i++)&#123;        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;&#125;void change(int *a,int *b)&#123;//可以直接用swap代替     int t=*a;    *a=*b;    *b=t;&#125;void choose(int *a)&#123;    int i,k,j;    for(j=0;j&lt;99;j++)&#123;        k=j;        i=j+1;        while(i&lt;=99)&#123;        a[i]&lt;a[k]?k=i:i++;        &#125;        if(k!=j)            change(&amp;a[j],&amp;a[k]);    &#125;&#125;void stick(int *a)&#123;    int t,i,j;    for (i=0;i&lt;99;i++)    &#123;        t=a[i+1];        for(j=i;j&gt;=0&amp;&amp;a[j]&gt;t;j--)        &#123;            a[j+1]=a[j];        &#125;        a[j+1]=t;    &#125;&#125;void bubbling(int *a)&#123;    for(int i=0;i&lt;99;i++)&#123;        for(int j=99;j&gt;i;j--)&#123;            if(a[j]&lt;a[j-1])                change(&amp;a[j],&amp;a[j-1]);        &#125;    &#125;    &#125;void fast(int left,int right,int *a)&#123;    if(left&gt;=right)return;    int i=left,j=right,base=a[left];    while(i&lt;j)&#123;        while(a[j]&gt;=base &amp;&amp; i&lt;j)j--;        while(a[i]&lt;=base &amp;&amp; i&lt;j)i++;        if(i&lt;j)            change(&amp;a[i],&amp;a[j]);    &#125;      a[left]=a[i];    a[i]=base;    fast(left,i-1,a);    fast(i+1,right,a);&#125;void shell(int *a)&#123;    int length=100,gap=1;    while(gap&lt;length)&#123;        gap=gap*3+1;    &#125;    while(gap&gt;0)&#123;        for(int i=gap;i&lt;length;i++)&#123;            int tmp=a[i],j=i-gap;            //跨区间排序            while(j&gt;=0&amp;&amp;a[j]&gt;tmp)&#123;                a[j+gap]=a[j];                j-=gap;            &#125;            a[j+gap]=tmp;        &#125;        gap=gap/3;    &#125;&#125;void merge(int *a,int l,int r)&#123;    if(l==r)return;//递归退出条件    int mid=l+r&gt;&gt;1;//中间值mid    merge(a,l,mid),merge(a,mid+1,r);    //合并    int k=l,i=l,j=mid+1,temp[1000];    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;        if(a[i]&lt;=a[j])//左大于右             temp[k++]=a[i++];        else             temp[k++]=a[j++];//两段相比小的放入到临时数组里面    &#125;    //如果一个数组已经遍历完了，另外一个数组剩余一个数，这个数一定是最大的。    while(i&lt;=mid)        temp[k++]=a[i++];    while(j&lt;=r)        temp[k++]=a[j++];     for(i=0;i&lt;=r;i++)&#123;         a[i]=temp[i];     &#125;&#125;void heap_sort(int* a,int len)&#123;//可以len=sizeof(a)/sizeof(int)        //初始化建堆：        for(int i=len/2-1;i&gt;=0;--i)//1.创建堆make_heap, 从最后一个非叶子节点开始                heap(a,i,len);         //排序重建堆             for(int i=len-1;i&gt;=0;i--)&#123;//2. 堆排序, 此时 [1, len] 为一个堆                swap(a[0],a[i]);           //堆顶元素和末尾元素进行交换                heap(a,0,i);        // 对顶点进行一次堆排序// 此时堆末元素已经有序(存的是最大值),        &#125;// 剩余堆的范围变成了 [1, len-1], 但由于上一步的交换可能破坏堆的性质, 故要进行调整&#125;void heap(int a[],int start,int length)//判断是不是符合大根堆&#123;        int left=2*start+1,right=2*start+2,max=start;        if(left&lt;length&amp;&amp;a[left]&gt;a[max])//left &lt;= len 防止节点不存在                max=left;        if(right&lt;length&amp;&amp;a[right]&gt;a[max])//a[right] &gt; a[max] 判断是不是根节点最大(因为你每个子树都要符合大根堆的性质啊)                max=right;        if(max!=start)&#123;                swap(a[max],a[start]);//交换节点                heap(a,max,length);//从当交换后前节点开始, 调整下面的堆        &#125;&#125;//这里的 max 是当前 father 的某一个儿子, 而不是 father 自身,　因为交换后 father 本来就是有序的.void gaynumber(int *a,int n) //基数排序&#123;    int d=1; //保存最大的位数    int p=10;    for(int i=0;i&lt;n;++i)    &#123;        while(a[i]&gt;=p)        &#123;            p*=10;            ++d;        &#125;    &#125;    int tmp[n],radix=1,i,j,k;    int count[10]; //计数器    for(i=1;i&lt;=d;i++) //进行d次排序    &#123;        for(j=0;j&lt;10;j++)            count[j]=0; //每次分配前清空计数器        for(j=0;j&lt;n;j++)        &#123;            k=(a[j]/radix)%10; //统计每个桶中的记录数            count[k]++;        &#125;        for(j=1;j&lt;10;j++)            count[j]=count[j-1]+count[j]; //将tmp中的位置依次分配给每个桶        for(j=n-1;j&gt;=0;j--) //将所有桶中记录依次收集到tmp中        &#123;            k=(a[j]/radix)%10;            tmp[count[k]-1]=a[j];            count[k]--;        &#125;        for(j=0;j&lt;n;j++) //将临时数组的内容复制到a中            a[j]=tmp[j];        radix=radix*10;    &#125;&#125;void radixsort(int *a,int n)&#123;      int tank[20][100];         //20个桶, tank[x][i]表示当前位是x的第i个数，这里tank[x][0]表示tank[x]这个数组有多少个元素,故存数据时从tank[x][1]开始存    int k=1,d=1;        //k是最大位数，d是当前位的权重，即1, 10, 100.....        //计算最大位数, 公式 k = (int)log10(x) + 1，注意x要大于0    for(int i=0;i&lt;n;i++)         if(a[i])        //非零时, 计算 |a[i]| 的位数            k=max((int)log10(abs(a[i]))+1,k);        while(k--)&#123;            //循环k次        memset(tank,0,sizeof(tank));        //每次循环先把tank清零                for(int i=0;i&lt;n;i++)&#123;        //枚举n个数            int x=a[i]/d%10+10; //得到当前位的值x（记得要加10）            tank[x][++tank[x][0]]=a[i];     //放到第x个桶里面，注意是++tank[x][0]        &#125;                int cnt=0;        for(int i=0;i&lt;20;i++)       //枚举20个桶            //依次拿出每个桶里面的值[1, tank[i][0]], 注意取出顺序和放入顺序是一样的（类似队列,先进先出），故基数排序稳定            for(int j=1;j&lt;=tank[i][0];j++)                   a[cnt++]=tank[i][j];        //回收        d*=10;        //权重 * 10    &#125; &#125;void bucket(int *a)&#123;    int b[201]=&#123;0&#125;,j=0,s;    for(int i=0;i&lt;100;i++)&#123;        b[a[i]+100]++;    &#125;    for(int i=0;i&lt;=200;i++)&#123;        if(b[i]!=0)            for(s=0;s&lt;b[i];s++)                a[j++]=i-100;    &#125;&#125; void odd_even(int *a)&#123;    int sort=0,i;    while(!sort)&#123;      sort=1;      for(i=1;i&lt;100;i+=2)&#123;         if(a[i]&gt;a[i+1])&#123;            swap(a[i],a[i+1]);            sort=0;         &#125;      &#125;      for(i=0;i&lt;99;i+=2)&#123;         if(a[i]&gt;a[i+1])&#123;            swap(a[i],a[i+1]);            sort=0;         &#125;      &#125;   &#125;&#125;</code></pre><table width=100% bgcolor="#eff8f0" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #5cb85c" ><!--<tr>  <th align="left" style="color: black">Python代码： </th></tr><tr>-->   <td align="left" style="color: black">       Python代码：    <br/></br/> &emsp;&emsp;  巴拉巴拉巴拉    巴拉巴拉</td></tr></table><pre><code class="python">import easygui as egdef GetGongshi(): # 简易Gui    eg.textbox(msg=&quot;输入合式公式(字母大写,不超过四个,联结词从高到底出现):&quot;,text=&quot;非：!\n合：&amp;\n析取：|\n蕴含：&gt;\n等价：-\n点击OK进入下一步&quot;)    msg=&quot;请输入命题变元的数量(1-4):&quot;    while 1:        num = eg.enterbox(msg,title=&quot;求命题公式的真值表&quot;)        if num == &quot;1&quot;:            Gongshi=eg.enterbox(msg=&quot;请输入公式\n(命题变元用P表示)\n(非为&#39;!&#39;,合取为&#39;&amp;&#39;,析取为&#39;|&#39;,蕴含为&#39;&gt;&#39;,等价为&#39;-&#39;)&quot;,title=&quot;求命题公式的真值表&quot;)            break        elif num == &quot;2&quot;:            Gongshi = eg.enterbox(msg=&quot;请输入公式\n(命题变元用P、Q表示)\n(非为&#39;!&#39;,合取为&#39;&amp;&#39;,析取为&#39;|&#39;,蕴含为&#39;&gt;&#39;,等价为&#39;-&#39;)&quot;, title=&quot;求命题公式的真值表&quot;)            break        elif num == &quot;3&quot;:            Gongshi = eg.enterbox(msg=&quot;请输入公式\n(命题变元用P、Q、R表示)\n(非为&#39;!&#39;,合取为&#39;&amp;&#39;,析取为&#39;|&#39;,蕴含为&#39;&gt;&#39;,等价为&#39;-&#39;)&quot;, title=&quot;求命题公式的真值表&quot;)            break        elif num == &quot;4&quot;:            Gongshi = eg.enterbox(msg=&quot;请输入公式\n(命题变元用P、Q、R、S表示)\n(非为&#39;!&#39;,合取为&#39;&amp;&#39;,析取为&#39;|&#39;,蕴含为&#39;&gt;&#39;,等价为&#39;-&#39;)&quot;, title=&quot;求命题公式的真值表&quot;)            break        else:            msg = &quot;输入有误请重新输入\n请输入命题变元的数量(1-4):&quot;    return Gongshi+num#获取逆波兰顺序转化后的公式def GetNiBoLan(Gongshi):             #Gongshi转为列表    Fuhao = [&quot;!&quot;,&quot;|&quot;,&quot;&amp;&quot;,&quot;&gt;&quot;,&quot;-&quot;,&quot;(&quot;]    Yuansu = [&quot;P&quot;,&quot;Q&quot;,&quot;R&quot;,&quot;S&quot;]    FuhaoZhan = []    NiBoLan = []    GS_pop = &quot;&quot;    FH_pop = &quot;&quot;    while len(Gongshi)!=0:        GS_pop = Gongshi.pop(0)        if GS_pop in Fuhao:            if len(FuhaoZhan) != 0:                if FuhaoZhan[-1] == &quot;!&quot; and GS_pop!=&quot;(&quot;:                    NiBoLan.append(FuhaoZhan.pop())            FuhaoZhan.append(GS_pop)        elif GS_pop in Yuansu:            NiBoLan.append(GS_pop)            if len(FuhaoZhan) != 0:                if FuhaoZhan[-1] == &quot;!&quot;:                    NiBoLan.append(FuhaoZhan.pop())        elif GS_pop == &quot;)&quot;:            FH_pop = FuhaoZhan.pop()            while FH_pop != &quot;(&quot;:                NiBoLan.append(FH_pop)                FH_pop = FuhaoZhan.pop()    while len(FuhaoZhan) != 0:        FH_pop = FuhaoZhan.pop()        NiBoLan.append(FH_pop)    return NiBoLan#各符号的逻辑运算def JiSuan(*CanShu):   #收集参数，因为参数个可能为一个或者两个：    # 下面分别是析取、合取、蕴含、等价的逻辑运算    if CanShu[0] == &quot;|&quot;:        if CanShu[1] == 1 or CanShu[2] == 1:            return 1        else:            return 0    if CanShu[0] == &quot;&amp;&quot;:        if CanShu[1] == 0 or CanShu[2] == 0:            return 0        else:            return 1    if CanShu[0] == &quot;&gt;&quot;:        if CanShu[1] == 1 and CanShu[2] == 0:            return 0        else:            return 1    if CanShu[0] == &quot;-&quot;:        if CanShu[1] != CanShu[2]:            return 0        else:            return 1    if CanShu[0] == &quot;!&quot;:        if CanShu[1] == 1:            return 0        else:            return 1#获得真值表def GetValue(NiBoLan,num):   # num为命题变元个数    NiBoLanList=NiBoLan.copy()  #这个列表用来存储逆波兰表达式，方便多次输出    Fuhao = [ &quot;|&quot;, &quot;&amp;&quot;, &quot;&gt;&quot;, &quot;-&quot;] #逆波兰表达式把括号去掉了,&quot;!&quot;作为特殊位运算做特例处理    Yuansu = [&quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;]    YuansuZhan = []    YS_value = &#123;&quot;P&quot;:0,&quot;Q&quot;:0,&quot;R&quot;:0,&quot;S&quot;:0,&quot;K&quot;:0&#125; #这里用字典来匹配变元字符的逻辑值，k为计算过程中的临时变量，默认值都为0    NBL_pop = &quot;&quot;    Value = [] #存储所有赋值情况下公式的真值(按赋值顺序存储就行)    YS_valuelist = []#储存真值赋值    count = 0 #控制循环    YS_temp=&quot;&quot;    while count &lt; 2**num:        NiBoLanList = NiBoLan.copy() #每次循环重置逆波兰列表值        YS_value = &#123;&quot;P&quot;: 0, &quot;Q&quot;: 0, &quot;R&quot;: 0, &quot;S&quot;: 0, &quot;K&quot;: 0&#125; #字典重置        YS_temp = bin(count)[2:] #十进制转二进制        YS_temp = [int(each) for each in YS_temp] #二进制字符串转列表        YS_temp.reverse()        while len(YS_temp) &lt; num:                                 #长度小于num时其他位赋值0            YS_temp.append(0)        YS_temp.reverse()        YS_valuelist.append(YS_temp[:])        while len(YS_temp) &lt; 4:            YS_temp.append(0)                                   #保证标准的输出格数pqrs        YS_value[&quot;P&quot;] = YS_temp[0]        YS_value[&quot;Q&quot;] = YS_temp[1]        YS_value[&quot;R&quot;] = YS_temp[2]        YS_value[&quot;S&quot;] = YS_temp[3]        while  len(NiBoLanList) != 0:            NBL_pop=NiBoLanList.pop(0)            if NBL_pop in Yuansu:                YuansuZhan.append(NBL_pop)            elif NBL_pop in Fuhao:                YS_value[&quot;K&quot;] = JiSuan(NBL_pop,YS_value[YuansuZhan.pop(-2)],YS_value[YuansuZhan.pop()])  #只要不是否定,从元素栈顶pop变元出来用字典转换后进行逻辑计算                YuansuZhan.append(&quot;K&quot;)            elif NBL_pop == &quot;!&quot;:                YS_value[&quot;K&quot;] = JiSuan(NBL_pop, YS_value[YuansuZhan.pop()])                YuansuZhan.append(&quot;K&quot;)        Value.append(YS_value[YuansuZhan.pop(0)])        count += 1    YS_valuelist.append(Value)    print(YS_valuelist)    return  YS_valuelist#打印真值表，主析取范式，主合取范式def FormPrint(YS_valuelist, num):    value=YS_valuelist.pop()    msg=&quot;公式&#123;0&#125;真值表结果如下:\n&quot;.format(GongShiChar)    YuansuList=[&quot;P&quot;,&quot;Q&quot;,&quot;R&quot;,&quot;S&quot;]    #输出真值表    for i in range(num):        msg = msg+&quot;   &quot;+YuansuList[i]+&quot;    &quot;    msg = msg+&quot;    &quot;+&quot;&quot;.join(GongShiChar)+&quot;\n&quot;    for i in range(len(YS_valuelist)):        for each in YS_valuelist[i]:            msg = msg+&quot;   &quot;+str(each)+&quot;    &quot;        msg = msg+&quot;    &quot;+str(value[i])+&quot;    \n&quot;    #输出主析取范式    msg = msg+&quot;主析取范式为：&quot;    for each in YS_valuelist:        if value[YS_valuelist.index(each)] == 1:            msg = msg+&quot;(&quot;            for i in range(len(each)):                if each[i] == 1:                    msg = msg+YuansuList[i]                else:                    msg = msg+&quot;!&quot;+YuansuList[i]                if i != len(each)-1:                    msg = msg+&quot;&amp;&quot;            msg = msg+&quot;)&quot;            if  1 in  value[YS_valuelist.index(each)+1:]:                msg = msg+&quot;|&quot;    #输出主合取范式    msg = msg +&quot;\n主合取范式为：&quot;    for each in YS_valuelist:        if value[YS_valuelist.index(each)] == 0:            msg = msg+&quot;(&quot;            for i in range(len(each)):                if each[i] == 0:                    msg = msg+YuansuList[i]                else:                    msg = msg+&quot;!&quot;+YuansuList[i]                if i != len(each)-1:                    msg = msg+&quot;|&quot;            msg = msg+&quot;)&quot;            if  0 in  value[YS_valuelist.index(each)+1:]:                msg = msg+&quot;&amp;&quot;    eg.msgbox(msg,title=&quot;输出结果&quot;)#主函数部分GongShi_And_num = GetGongshi()GongShi = [each for each in GongShi_And_num]#字符串列表化num = int(GongShi.pop())GongShiChar=GongShi_And_num[:-1]NiBoLan = GetNiBoLan(GongShi)YS_valuelist = GetValue(NiBoLan,num)FormPrint(YS_valuelist,num)</code></pre><table width=100% bgcolor="#fcf1f2" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #d9534f" ><tr>  <th align="left" style="color: black">Java代码：</th></tr></table><pre><code class="java">package mybank;import javafx.scene.layout.Pane;import javax.swing.*;import java.awt.event.ActionListener;import java.io.*;import java.util.ArrayList;import java.util.List;public class Test &#123;    public static List&lt;Account&gt; usersList;    public static Account currentAccount;//登录的用户    public static File file;//当前用户的记录文件    public static StringBuilder recordString=new StringBuilder();//登录后读取文本中的记录，然后和recordString拼接    public static Menu menu;//静态的菜单界面，用于在更换密码后关闭菜单界面    public static File usersFile;    public static StringBuilder usersString=new StringBuilder();     static Reader fw;    public static void main(String[] args)throws Exception &#123;        usersList = new ArrayList&lt;Account&gt;();        //System.out.println(usersList);        /**********************用户文本**********************/        File users = new File(&quot;users.txt&quot;);        if (!users.exists()) &#123;            try &#123;                users.createNewFile();                Writer fw = new FileWriter(&quot;users.txt&quot;);                fw.write(&quot;admin  12345   88888&quot;);                fw.flush();                fw.close();            &#125; catch (Exception e1) &#123;                JOptionPane.showMessageDialog(null, &quot;创建用户文档失败&quot;);            &#125;        &#125;        usersFile = users;//创建用户文档，存储用户账户，密码，余额信息;        usersListRead();        usersListUpdate();        /*****************************Login****************************/        LoginGui loginGui = new LoginGui();    &#125;    public static void usersListRead()    &#123;        /**********************按照用户文档读取用户列表并创建所有用户**********************/        /**********************并写入list**********************/        try &#123;            fw = new FileReader(&quot;users.txt&quot;);//字符流        &#125; catch (Exception e) &#123;            System.out.println(&quot;字符流创建失败&quot;);        &#125;        BufferedReader bfr = new BufferedReader(fw);        String temp = &quot;&quot;;        try &#123;            System.out.println(&quot;开始写入list&quot;);            while ((temp = bfr.readLine()) != null) &#123;//不知为何读取出的字符串中最前面会出现Null                String[] tmpstr = new String[5];                tmpstr = temp.split(&quot;\\s+&quot;);//分割空格                System.out.println(&quot;余额：&quot; + tmpstr[2]);                Account a = new Account(tmpstr[0], tmpstr[1], tmpstr[2]);                usersList.add(a);                System.out.println(&quot;读取到&quot;+a.id+&quot;,实例化用户&quot; + a.id);            &#125;            bfr.close();            fw.close();            System.out.println(&quot;用户list:&quot;+usersList);        &#125; catch (Exception e) &#123;            System.out.println(&quot;读取用户文档失败&quot;);        &#125;    &#125;    public static void usersListUpdate()    &#123;        /**********************按照list内容写入文本用户信息**********************/        try &#123;        Writer fw = new FileWriter(&quot;users.txt&quot;);        StringBuilder tmpstr = new StringBuilder();        for (int i = 0; i &lt; usersList.size(); i++) &#123;           // System.out.println(Test.currentAccount.id);            tmpstr.append(usersList.get(i).id + &quot;    &quot; + usersList.get(i).password + &quot;    &quot; + usersList.get(i).money + &quot;\r\n&quot;);            //fw.write(Test.currentAccount.id + &quot;    &quot; + Test.currentAccount.password + &quot;    &quot; + Test.currentAccount.money+&quot;\r\n&quot;);        &#125;        fw.write(tmpstr.toString());        fw.flush();        fw.close();    &#125;    catch (Exception e)    &#123;        e.printStackTrace();        System.out.println(&quot;更新用户失败&quot;);    &#125;    &#125;&#125;</code></pre><table width=100% bgcolor="#fdf8ea" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #f0ad4e" ><tr>  <th align="left" style="color: black">C++代码：</th></tr></table><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std; template &lt;class T&gt;class SortableList&#123;    public:        int n;        T l[100];//输入的数组值        T a[100];//实际排序对象        SortableList(int max)        &#123;            n = max;        &#125;        void MergeSort();        void QuickSort();        void Input();        void Init();        void Output();        void Select(int k) &#123;              int j= Select(k,0,n-1,5);              cout&lt;&lt;&quot;第&quot;&lt;&lt;k&lt;&lt;&quot;小元素是：&quot;&lt;&lt; a[k-1]&lt;&lt; endl;       &#125;    private:        int PartitionPlus(int left, int right);        int Partition(int left, int right);        void Merge(int left, int mid, int right);        void MergeSort(int left, int right);        void QuickSort(int left, int right);        void InsertSort(int left, int right);        int Select(int k, int left, int right, int r);&#125;;template&lt;class T&gt;void SortableList&lt;T&gt;::Input()&#123;    for(int i = 0; i &lt; n; i++)        cin &gt;&gt; l[i];&#125;//Init()函数的作用是在两路合并排序结束后将序列恢复到初始序列//再进行快速排序template&lt;class T&gt;void SortableList&lt;T&gt;::Init()&#123;    for(int i = 0; i &lt; n; i++)        a[i] = l[i];&#125;template&lt;class T&gt;void SortableList&lt;T&gt;::Output()&#123;    for(int i = 0; i &lt; n; i++)        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl &lt;&lt; endl;&#125; //两路合并排序template&lt;class T&gt;void SortableList&lt;T&gt;::MergeSort()&#123;    MergeSort(0, n - 1);&#125;template&lt;class T&gt;void SortableList&lt;T&gt;::MergeSort(int left, int right)&#123;    if(left &lt; right)    &#123;        int mid = (left + right) / 2;        MergeSort(left, mid);        MergeSort(mid + 1, right);        Merge(left, mid, right);    &#125;&#125;template &lt;class T&gt;void SortableList&lt;T&gt;::Merge(int left, int mid, int right)&#123;    T* temp =new T[right - left + 1];    int i = left, j = mid + 1, k = 0;    while((i &lt;= mid)&amp;&amp;(j &lt;= right))        if(a[i] &lt;= a[j])            temp[k ++] = a[i ++];        else            temp[k ++] = a[j ++];    while(i &lt;= mid)        temp[k ++] = a[i ++];    while(j &lt;= right)        temp[k ++] = a[j ++];    for(i = 0, k = left; k &lt;= right;)        a[k ++] = temp[i ++];&#125; //快速排序template &lt;class T&gt;int SortableList&lt;T&gt;::PartitionPlus(int left, int right)&#123;    srand((unsigned)time(NULL));    int i = rand() % (right - left) + left;    swap(a[i], a[left]);    return Partition(left, right);&#125;template &lt;class T&gt;int SortableList&lt;T&gt;::Partition(int left, int right)&#123;    int i = left, j = right + 1;    do&#123;        do i ++; while(a[i] &lt; a[left]);        do j --; while(a[j] &gt; a[left]);        if(i &lt; j) swap(a[i], a[j]);    &#125;while(i &lt; j);    swap(a[left], a[j]);    return j;&#125;template&lt;class T&gt;void SortableList&lt;T&gt;::QuickSort()&#123;    QuickSort(0, n - 1);&#125;template &lt;class T&gt;void SortableList&lt;T&gt;::QuickSort(int left, int right)&#123;    if(left &lt; right)    &#123;        int j = PartitionPlus(left, right);        QuickSort(left, j - 1);        QuickSort(j + 1, right);    &#125;&#125;template &lt;class T&gt;void SortableList&lt;T&gt;::InsertSort(int left, int right)&#123;       for (int i = left + 1; i &lt;= right; i++)       &#123;              int j = i;              int temp = a[i];              while (j&gt;left&amp;&amp;temp&lt;a[j- 1])              &#123;                     a[j]= a[j - 1];                     j--;              &#125;              a[i]= temp;       &#125;&#125;template &lt;class T&gt;int SortableList&lt;T&gt;::Select(int k, int left, int right, int r)&#123;  //每个分组r个元素，寻找第k小元素       int n = right - left + 1;       if (n &lt;= r)       &#123;              InsertSort(left, right);              return left + k - 1;  //返回第k小元素的下标       &#125;       for (int i = 1; i &lt;= n/ r; i++)       &#123;              InsertSort(left + (i - 1)*r, left + i*r - 1);               //二次取中规则求每组的中间值              swap(a[left+i-1],a[left+(i-1)*r+(int)ceil((double)r/2)-1]);                //每组中间值到子表前部集中存放       &#125;       int j = Select((int)ceil((double)n / r / 2), left, left + n / r - 1, r);        //二次中间值下标为j       swap(a[left], a[j]);  //二次中间值为枢纽元，并换至left处       j= Partition(left, right);  //对表（子表）进行分划操作       if (k == j - left + 1)  //返回第k小元素下标              return j;       else if (k &lt; j - left + 1)  //在左子表求第k小元素              return Select(k, left, j - 1, r);       else              return Select(k - (j - left + 1), j + 1, right, r);                //在右子表求第k-(j-left+1)小元素&#125; int main()&#123;    int m,k;    cout &lt;&lt; &quot;请输入元素个数n: &quot;&lt;&lt; endl;    cin &gt;&gt; m;    SortableList&lt;int&gt; List(m);    cout &lt;&lt; &quot;输入&quot; &lt;&lt; m &lt;&lt; &quot;个数字:&quot; &lt;&lt; endl;    List.Input();    List.Init();//得到初始状态    List.MergeSort();    cout &lt;&lt; endl &lt;&lt; &quot;两路合并排序后：&quot; &lt;&lt; endl;    List.Output();    List.Init();//恢复初始状态    cout &lt;&lt; &quot;快速排序后：&quot; &lt;&lt; endl;    List.QuickSort();    List.Output();    cout&lt;&lt;&quot;请输入查找第k小元素的k值：&quot;&lt;&lt; endl;       cin&gt;&gt;k;    List.Select(k);    for (int i=1;i&lt;=m;i++)        List.Select(i);    return 0; &#125;</code></pre><h3 id="2-广告位"><a href="#2-广告位" class="headerlink" title="2.广告位"></a>2.广告位</h3><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/202305081430358.webp" alt="hackcode"></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时空の杂记</title>
      <link href="/loki/shikongMisc/"/>
      <url>/loki/shikongMisc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​许久没有写博客，先简单聊聊吧</p></blockquote><h3 id="1-浅学的一些东西"><a href="#1-浅学的一些东西" class="headerlink" title="1.浅学的一些东西"></a>1.浅学的一些东西</h3><p>因为大学前是没怎么接触电脑的小白（以前家里台式机，从小学开始接触过qq、4399等，在正经的计算机领域是green hand），做了不少没什么用的探索，网站的域名解析，使用集成环境搭建登录小网站，接触一些密码，写过简单爬虫……&#x2F;&#x2F;（<strong>大一上</strong>干的闲事）| ubuntu gnome界面macos化、qq nonebot聊天机器人、vscode等许多工具的简单配置、从0开始学vim、参加hvv护网行动……&#x2F;&#x2F;<strong>大一下</strong>干的闲事</p><p>学习了一些有关linux的知识，接触了一下manjaro kde plasma，neo vim<del>（被dash board吸引）</del>，有关ctfweb学习摆了许久，在组里人push下接触了一些pop链、ssti、文件上传漏洞、ssrf、许多cve以及一些常规的绕过。回首过往，发现还是贪玩摆烂的时间多，玩机器人，玩服务器，玩AI画图、gpt，都没干什么正经的项目。</p><p>看到了<strong>X1r0z</strong>学弟的blog，五六年前接触webctf以及实战一些相关内容，可谓web一神。</p><p>有关java后端的知识要开始启动了，捡了很久还没有捡起来的算法已经烂掉了，安全与开发于我而言不可同时兼顾，所以最近整了一下IDE，准备大干一场。</p><p>UWP、git、python tensorflow、jupyter也才刚刚起步，之前也是部署了属于自己的网站，博客园已经许久不写内容，还有一个迟迟未建的靶场……就是觉得时间有些不太够，要学的东西真的还有很多，现在我仍然不具备个人的开发能力，在web安全方面的成就也很有限，感觉学的五花八门反而不如专精一项，好提前进厂打工。&#x2F;&#x2F;（<strong>大二上</strong></p><p>以上均是大一下至大二上的想法了，现在我的方向全部转移到开发方向上来。</p><p>寒假青训营学习了一些go的知识，现阶段要Java与算法兼顾，边学边写博客，学校的专业课也会整理在github等平台。就业这条路对于本科生本就困难，既然要去争取，就要找准方向实干，人的能力终究是有限的，我不可能在这短短时间内学习大佬们口中无所不谈的各方向知识，我目前所能做的，就是入门开发。</p><p><strong>大二下</strong>学期过半。然而好像不知道到底干了什么、学了什么。还是老老实实看点后端基础，刷点算法吧……</p><h3 id="2-后续blog的更新周期以及内容"><a href="#2-后续blog的更新周期以及内容" class="headerlink" title="2.后续blog的更新周期以及内容"></a>2.后续blog的更新周期以及内容</h3><p>主要讲述本人零基础学习后端的过程，以及一些必要的算法，坚持每周都要至少产出一篇，可能在学习过程中遇到好玩的或是有意义的也会分享。（flag立于2023.5.3周三）</p><p>还望大佬来交流指正</p><p>过去的已成为过去，就</p><pre><code class="shell">sudo rm -rf/*       ——&gt;reboot</code></pre><p>迎接未来吧！</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/202305081430363.webp" alt="wallhaven-x67dgo"></p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 札记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to shikong&#39;s blog</title>
      <link href="/loki/hello-world/"/>
      <url>/loki/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Here is jackball24&#x2F;shikong’s blog, it is started on <strong>2023&#x2F;3&#x2F;20</strong>.</p><p>I’m a programming beginner, and have lots of things to learn.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Create-a-new-page"><a href="#Create-a-new-page" class="headerlink" title="Create a new page"></a>Create a new page</h3><pre><code class="bash">$ hexo new page aboutme</code></pre><p>More info: <a href="https://hexo.io/docs/commands">Commands | Hexo</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
