<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux简单命令入门</title>
      <link href="/loki/Linux-orders/"/>
      <url>/loki/Linux-orders/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的使用</title>
      <link href="/loki/Git-use/"/>
      <url>/loki/Git-use/</url>
      
        <content type="html"><![CDATA[<p>代码的对比以及版本管理</p><p>——回溯</p>]]></content>
      
      
      <categories>
          
          <category> 代码管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收集一些好的博文规范</title>
      <link href="/loki/fansyBlog/"/>
      <url>/loki/fansyBlog/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora &amp; Picgo &amp; GitXXX 图床使用</title>
      <link href="/loki/Typora-Picgo-GitXXX-Use/"/>
      <url>/loki/Typora-Picgo-GitXXX-Use/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 工具&amp;环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Code</title>
      <link href="/loki/My-Code/"/>
      <url>/loki/My-Code/</url>
      
        <content type="html"><![CDATA[<blockquote><p>高中到大二之前写过一些简单的有一点用处的代码（多指实验报告）</p></blockquote><p>目前为css代码样式测试，真·useful code还没整理好。</p><h3 id="1-Kinds-of-sort"><a href="#1-Kinds-of-sort" class="headerlink" title="1.Kinds of sort"></a>1.Kinds of sort</h3><p><del>其中有些奇奇怪怪的函数命名[&#x2F;滑稽]</del></p><table width=100% bgcolor="#eef7fa" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #428bca" ><tr>  <th align="left" style="color: black">C++代码：</th></tr></table><pre><code class="c++">#include&lt;bits/stdc++.h&gt;using namespace std;void choose(int *a);//选择 void stick(int *a);//插排 void bubbling(int *a);//冒泡 void fast(int left,int right,int *a);//快排 void shell(int *a);//希尔 void merge(int *a,int l,int r);//归并 void heap_sort(int *a,int len);//堆排 void gaynumber(int *a,int n);//基数(正数情况)void radixsort(int *a,int n);//基数(加强) void bucket(int *a);//桶排 void odd_even(int *a);//砖排(奇偶) void heap(int a[],int start,int length);void change(int *a,int *b);int main()&#123;    int i,a[100];     srand(time(0));    for(i=0;i&lt;100;i++)&#123;        a[i]=pow(-1,rand()%2+1)*(rand()%101);        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;//输出-100~100之间的随机数，可能重复     cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;排序后：&quot;&lt;&lt;endl&lt;&lt;endl;    //sort(a,a+100);//内置快速排序     //choose(a);    //stick(a);     //bubbling(a);    //fast(0,99,a);    shell(a);    //merge(a,0,99);     //heap_sort(a,100);    //gaynumber(a,100);    //radixsort(a,100);    //bucket(a);    //odd_even(a);        for(i=0;i&lt;100;i++)&#123;        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    &#125;&#125;void change(int *a,int *b)&#123;//可以直接用swap代替     int t=*a;    *a=*b;    *b=t;&#125;void choose(int *a)&#123;    int i,k,j;    for(j=0;j&lt;99;j++)&#123;        k=j;        i=j+1;        while(i&lt;=99)&#123;        a[i]&lt;a[k]?k=i:i++;        &#125;        if(k!=j)            change(&amp;a[j],&amp;a[k]);    &#125;&#125;void stick(int *a)&#123;    int t,i,j;    for (i=0;i&lt;99;i++)    &#123;        t=a[i+1];        for(j=i;j&gt;=0&amp;&amp;a[j]&gt;t;j--)        &#123;            a[j+1]=a[j];        &#125;        a[j+1]=t;    &#125;&#125;void bubbling(int *a)&#123;    for(int i=0;i&lt;99;i++)&#123;        for(int j=99;j&gt;i;j--)&#123;            if(a[j]&lt;a[j-1])                change(&amp;a[j],&amp;a[j-1]);        &#125;    &#125;    &#125;void fast(int left,int right,int *a)&#123;    if(left&gt;=right)return;    int i=left,j=right,base=a[left];    while(i&lt;j)&#123;        while(a[j]&gt;=base &amp;&amp; i&lt;j)j--;        while(a[i]&lt;=base &amp;&amp; i&lt;j)i++;        if(i&lt;j)            change(&amp;a[i],&amp;a[j]);    &#125;      a[left]=a[i];    a[i]=base;    fast(left,i-1,a);    fast(i+1,right,a);&#125;void shell(int *a)&#123;    int length=100,gap=1;    while(gap&lt;length)&#123;        gap=gap*3+1;    &#125;    while(gap&gt;0)&#123;        for(int i=gap;i&lt;length;i++)&#123;            int tmp=a[i],j=i-gap;            //跨区间排序            while(j&gt;=0&amp;&amp;a[j]&gt;tmp)&#123;                a[j+gap]=a[j];                j-=gap;            &#125;            a[j+gap]=tmp;        &#125;        gap=gap/3;    &#125;&#125;void merge(int *a,int l,int r)&#123;    if(l==r)return;//递归退出条件    int mid=l+r&gt;&gt;1;//中间值mid    merge(a,l,mid),merge(a,mid+1,r);    //合并    int k=l,i=l,j=mid+1,temp[1000];    while(i&lt;=mid&amp;&amp;j&lt;=r)&#123;        if(a[i]&lt;=a[j])//左大于右             temp[k++]=a[i++];        else             temp[k++]=a[j++];//两段相比小的放入到临时数组里面    &#125;    //如果一个数组已经遍历完了，另外一个数组剩余一个数，这个数一定是最大的。    while(i&lt;=mid)        temp[k++]=a[i++];    while(j&lt;=r)        temp[k++]=a[j++];     for(i=0;i&lt;=r;i++)&#123;         a[i]=temp[i];     &#125;&#125;void heap_sort(int* a,int len)&#123;//可以len=sizeof(a)/sizeof(int)        //初始化建堆：        for(int i=len/2-1;i&gt;=0;--i)//1.创建堆make_heap, 从最后一个非叶子节点开始                heap(a,i,len);         //排序重建堆             for(int i=len-1;i&gt;=0;i--)&#123;//2. 堆排序, 此时 [1, len] 为一个堆                swap(a[0],a[i]);           //堆顶元素和末尾元素进行交换                heap(a,0,i);        // 对顶点进行一次堆排序// 此时堆末元素已经有序(存的是最大值),        &#125;// 剩余堆的范围变成了 [1, len-1], 但由于上一步的交换可能破坏堆的性质, 故要进行调整&#125;void heap(int a[],int start,int length)//判断是不是符合大根堆&#123;        int left=2*start+1,right=2*start+2,max=start;        if(left&lt;length&amp;&amp;a[left]&gt;a[max])//left &lt;= len 防止节点不存在                max=left;        if(right&lt;length&amp;&amp;a[right]&gt;a[max])//a[right] &gt; a[max] 判断是不是根节点最大(因为你每个子树都要符合大根堆的性质啊)                max=right;        if(max!=start)&#123;                swap(a[max],a[start]);//交换节点                heap(a,max,length);//从当交换后前节点开始, 调整下面的堆        &#125;&#125;//这里的 max 是当前 father 的某一个儿子, 而不是 father 自身,　因为交换后 father 本来就是有序的.void gaynumber(int *a,int n) //基数排序&#123;    int d=1; //保存最大的位数    int p=10;    for(int i=0;i&lt;n;++i)    &#123;        while(a[i]&gt;=p)        &#123;            p*=10;            ++d;        &#125;    &#125;    int tmp[n],radix=1,i,j,k;    int count[10]; //计数器    for(i=1;i&lt;=d;i++) //进行d次排序    &#123;        for(j=0;j&lt;10;j++)            count[j]=0; //每次分配前清空计数器        for(j=0;j&lt;n;j++)        &#123;            k=(a[j]/radix)%10; //统计每个桶中的记录数            count[k]++;        &#125;        for(j=1;j&lt;10;j++)            count[j]=count[j-1]+count[j]; //将tmp中的位置依次分配给每个桶        for(j=n-1;j&gt;=0;j--) //将所有桶中记录依次收集到tmp中        &#123;            k=(a[j]/radix)%10;            tmp[count[k]-1]=a[j];            count[k]--;        &#125;        for(j=0;j&lt;n;j++) //将临时数组的内容复制到a中            a[j]=tmp[j];        radix=radix*10;    &#125;&#125;void radixsort(int *a,int n)&#123;      int tank[20][100];         //20个桶, tank[x][i]表示当前位是x的第i个数，这里tank[x][0]表示tank[x]这个数组有多少个元素,故存数据时从tank[x][1]开始存    int k=1,d=1;        //k是最大位数，d是当前位的权重，即1, 10, 100.....        //计算最大位数, 公式 k = (int)log10(x) + 1，注意x要大于0    for(int i=0;i&lt;n;i++)         if(a[i])        //非零时, 计算 |a[i]| 的位数            k=max((int)log10(abs(a[i]))+1,k);        while(k--)&#123;            //循环k次        memset(tank,0,sizeof(tank));        //每次循环先把tank清零                for(int i=0;i&lt;n;i++)&#123;        //枚举n个数            int x=a[i]/d%10+10; //得到当前位的值x（记得要加10）            tank[x][++tank[x][0]]=a[i];     //放到第x个桶里面，注意是++tank[x][0]        &#125;                int cnt=0;        for(int i=0;i&lt;20;i++)       //枚举20个桶            //依次拿出每个桶里面的值[1, tank[i][0]], 注意取出顺序和放入顺序是一样的（类似队列,先进先出），故基数排序稳定            for(int j=1;j&lt;=tank[i][0];j++)                   a[cnt++]=tank[i][j];        //回收        d*=10;        //权重 * 10    &#125; &#125;void bucket(int *a)&#123;    int b[201]=&#123;0&#125;,j=0,s;    for(int i=0;i&lt;100;i++)&#123;        b[a[i]+100]++;    &#125;    for(int i=0;i&lt;=200;i++)&#123;        if(b[i]!=0)            for(s=0;s&lt;b[i];s++)                a[j++]=i-100;    &#125;&#125; void odd_even(int *a)&#123;    int sort=0,i;    while(!sort)&#123;      sort=1;      for(i=1;i&lt;100;i+=2)&#123;         if(a[i]&gt;a[i+1])&#123;            swap(a[i],a[i+1]);            sort=0;         &#125;      &#125;      for(i=0;i&lt;99;i+=2)&#123;         if(a[i]&gt;a[i+1])&#123;            swap(a[i],a[i+1]);            sort=0;         &#125;      &#125;   &#125;&#125;</code></pre><table width=100% bgcolor="#eff8f0" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #5cb85c" ><!--<tr>  <th align="left" style="color: black">Python代码： </th></tr><tr>-->   <td align="left" style="color: black">       Python代码：    <br/></br/> &emsp;&emsp;  巴拉巴拉巴拉    巴拉巴拉</td></tr></table><table width=100% bgcolor="#fcf1f2" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #d9534f" ><tr>  <th align="left" style="color: black">Java代码：</th></tr></table><table width=100% bgcolor="#fdf8ea" cellspacing="10"  style=" overflow: hidden; border:1.8px solid #ffffff; border-left: 5px solid #f0ad4e" ><tr>  <th align="left" style="color: black">快排、合并：</th></tr></table><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std; template &lt;class T&gt;class SortableList&#123;    public:        int n;        T l[100];//输入的数组值        T a[100];//实际排序对象        SortableList(int max)        &#123;            n = max;        &#125;        void MergeSort();        void QuickSort();        void Input();        void Init();        void Output();        void Select(int k) &#123;              int j= Select(k,0,n-1,5);              cout&lt;&lt;&quot;第&quot;&lt;&lt;k&lt;&lt;&quot;小元素是：&quot;&lt;&lt; a[k-1]&lt;&lt; endl;       &#125;    private:        int PartitionPlus(int left, int right);        int Partition(int left, int right);        void Merge(int left, int mid, int right);        void MergeSort(int left, int right);        void QuickSort(int left, int right);        void InsertSort(int left, int right);        int Select(int k, int left, int right, int r);&#125;;template&lt;class T&gt;void SortableList&lt;T&gt;::Input()&#123;    for(int i = 0; i &lt; n; i++)        cin &gt;&gt; l[i];&#125;//Init()函数的作用是在两路合并排序结束后将序列恢复到初始序列//再进行快速排序template&lt;class T&gt;void SortableList&lt;T&gt;::Init()&#123;    for(int i = 0; i &lt; n; i++)        a[i] = l[i];&#125;template&lt;class T&gt;void SortableList&lt;T&gt;::Output()&#123;    for(int i = 0; i &lt; n; i++)        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl &lt;&lt; endl;&#125; //两路合并排序template&lt;class T&gt;void SortableList&lt;T&gt;::MergeSort()&#123;    MergeSort(0, n - 1);&#125;template&lt;class T&gt;void SortableList&lt;T&gt;::MergeSort(int left, int right)&#123;    if(left &lt; right)    &#123;        int mid = (left + right) / 2;        MergeSort(left, mid);        MergeSort(mid + 1, right);        Merge(left, mid, right);    &#125;&#125;template &lt;class T&gt;void SortableList&lt;T&gt;::Merge(int left, int mid, int right)&#123;    T* temp =new T[right - left + 1];    int i = left, j = mid + 1, k = 0;    while((i &lt;= mid)&amp;&amp;(j &lt;= right))        if(a[i] &lt;= a[j])            temp[k ++] = a[i ++];        else            temp[k ++] = a[j ++];    while(i &lt;= mid)        temp[k ++] = a[i ++];    while(j &lt;= right)        temp[k ++] = a[j ++];    for(i = 0, k = left; k &lt;= right;)        a[k ++] = temp[i ++];&#125; //快速排序template &lt;class T&gt;int SortableList&lt;T&gt;::PartitionPlus(int left, int right)&#123;    srand((unsigned)time(NULL));    int i = rand() % (right - left) + left;    swap(a[i], a[left]);    return Partition(left, right);&#125;template &lt;class T&gt;int SortableList&lt;T&gt;::Partition(int left, int right)&#123;    int i = left, j = right + 1;    do&#123;        do i ++; while(a[i] &lt; a[left]);        do j --; while(a[j] &gt; a[left]);        if(i &lt; j) swap(a[i], a[j]);    &#125;while(i &lt; j);    swap(a[left], a[j]);    return j;&#125;template&lt;class T&gt;void SortableList&lt;T&gt;::QuickSort()&#123;    QuickSort(0, n - 1);&#125;template &lt;class T&gt;void SortableList&lt;T&gt;::QuickSort(int left, int right)&#123;    if(left &lt; right)    &#123;        int j = PartitionPlus(left, right);        QuickSort(left, j - 1);        QuickSort(j + 1, right);    &#125;&#125;template &lt;class T&gt;void SortableList&lt;T&gt;::InsertSort(int left, int right)&#123;       for (int i = left + 1; i &lt;= right; i++)       &#123;              int j = i;              int temp = a[i];              while (j&gt;left&amp;&amp;temp&lt;a[j- 1])              &#123;                     a[j]= a[j - 1];                     j--;              &#125;              a[i]= temp;       &#125;&#125;template &lt;class T&gt;int SortableList&lt;T&gt;::Select(int k, int left, int right, int r)&#123;  //每个分组r个元素，寻找第k小元素       int n = right - left + 1;       if (n &lt;= r)       &#123;              InsertSort(left, right);              return left + k - 1;  //返回第k小元素的下标       &#125;       for (int i = 1; i &lt;= n/ r; i++)       &#123;              InsertSort(left + (i - 1)*r, left + i*r - 1);               //二次取中规则求每组的中间值              swap(a[left+i-1],a[left+(i-1)*r+(int)ceil((double)r/2)-1]);                //每组中间值到子表前部集中存放       &#125;       int j = Select((int)ceil((double)n / r / 2), left, left + n / r - 1, r);        //二次中间值下标为j       swap(a[left], a[j]);  //二次中间值为枢纽元，并换至left处       j= Partition(left, right);  //对表（子表）进行分划操作       if (k == j - left + 1)  //返回第k小元素下标              return j;       else if (k &lt; j - left + 1)  //在左子表求第k小元素              return Select(k, left, j - 1, r);       else              return Select(k - (j - left + 1), j + 1, right, r);                //在右子表求第k-(j-left+1)小元素&#125; int main()&#123;    int m,k;    cout &lt;&lt; &quot;请输入元素个数n: &quot;&lt;&lt; endl;    cin &gt;&gt; m;    SortableList&lt;int&gt; List(m);    cout &lt;&lt; &quot;输入&quot; &lt;&lt; m &lt;&lt; &quot;个数字:&quot; &lt;&lt; endl;    List.Input();    List.Init();//得到初始状态    List.MergeSort();    cout &lt;&lt; endl &lt;&lt; &quot;两路合并排序后：&quot; &lt;&lt; endl;    List.Output();    List.Init();//恢复初始状态    cout &lt;&lt; &quot;快速排序后：&quot; &lt;&lt; endl;    List.QuickSort();    List.Output();    cout&lt;&lt;&quot;请输入查找第k小元素的k值：&quot;&lt;&lt; endl;       cin&gt;&gt;k;    List.Select(k);    for (int i=1;i&lt;=m;i++)        List.Select(i);    return 0; &#125;</code></pre><h3 id="2-广告位"><a href="#2-广告位" class="headerlink" title="2.广告位"></a>2.广告位</h3><p>目前为代码样式测试，真·useful code还没整理好</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/202305081430358.webp" alt="hackcode"></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时空の杂记</title>
      <link href="/loki/shikongMisc/"/>
      <url>/loki/shikongMisc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​许久没有写博客，先简单聊聊吧</p></blockquote><h3 id="1-浅学的一些东西"><a href="#1-浅学的一些东西" class="headerlink" title="1.浅学的一些东西"></a>1.浅学的一些东西</h3><p>因为大学前是没怎么接触电脑的小白（以前家里台式机，从小学开始接触过qq、4399等，在正经的计算机领域是green hand），做了不少没什么用的探索，虚拟机，网站的域名解析，使用集成环境搭建登录小网站，接触过一些密码，写过简单爬虫……&#x2F;&#x2F;（<strong>大一上</strong>干的闲事）| ubuntu gnome界面macos化、qq nonebot聊天机器人、vscode等许多工具的简单配置、从0开始学vim、学点ctfweb、参加hvv护网行动……&#x2F;&#x2F;<strong>大一下</strong>干的闲事</p><p>学习了一些有关linux的知识，接触了一下manjaro kde plasma，neo vim<del>（被dash board吸引）</del>，有关ctfweb学习摆了许久，在组里人push下接触了一些pop链、ssti、文件上传漏洞、ssrf、许多cve以及一些常规的绕过。回首过往，发现还是贪玩摆烂的时间多，玩机器人，玩服务器，玩AI画图、gpt，都没干什么正经的项目。</p><p>看到了<strong>X1r0z</strong>学弟的blog，五六年前接触webctf以及实战一些相关内容，可谓web一神。顺便膜一膜身边的dalao：huangx、picpo、winmt、sCh3n、NKID00……</p><p>有关java后端的知识要开始启动了，捡了很久还没有捡起来的算法已经烂掉了，安全与开发于我而言不可同时兼顾，所以当时准备从中选择一项深入。</p><p>UWP、git、python tensorflow、jupyter也才刚刚起步，之前也是部署了属于自己的网站（非本站），博客园已经许久不写内容，还有一个迟迟未建的靶场……就是觉得时间有些不太够，要学的东西真的还有很多，现在我仍然不具备个人的开发能力，在web安全方面的成就也很有限，感觉学的五花八门反而不如专精一项，好提前进厂打工。&#x2F;&#x2F;（<strong>大二上</strong></p><p>以上均是大一下至大二上的想法了，现在我的方向全部转移到开发方向上来。</p><p>寒假青训营学习了一些go的知识，现阶段要Java与算法兼顾，边学边写博客，学校的专业课也会整理在github等平台。就业这条路对于本科生本就困难，既然要去争取，就要找准方向实干，人的能力终究是有限的，我不可能在这短短时间内学习大佬们口中无所不谈的各方向知识，我目前所能做的，就是入门开发。</p><p><strong>大二下</strong>学期过半。然而好像不知道到底干了什么、学了什么。还是老老实实看点后端基础，刷点算法吧……</p><h3 id="2-后续blog的更新周期以及内容"><a href="#2-后续blog的更新周期以及内容" class="headerlink" title="2.后续blog的更新周期以及内容"></a>2.后续blog的更新周期以及内容</h3><p>主要讲述本人零基础学习后端的过程，以及一些必要的算法，坚持每周都要至少产出一篇，可能在学习过程中遇到好玩的或是有意义的也会分享。（flag立于2023.5.3周三）</p><p>还望大佬来交流指正</p><p>过去的已成为过去，就</p><pre><code class="shell">sudo rm -rf/*       ——&gt;reboot</code></pre><p>迎接未来吧！</p><p><img src="https://cdn.jsdelivr.net/gh/jackball24/Myblog_pic@main/202305081430363.webp" alt="wallhaven-x67dgo"></p>]]></content>
      
      
      <categories>
          
          <category> 闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 札记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to shikong&#39;s blog</title>
      <link href="/loki/hello-world/"/>
      <url>/loki/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Here is jackball24&#x2F;shikong’s blog, it is started on <strong>2023&#x2F;3&#x2F;20</strong>.</p><p>I’m a programming beginner, and have lots of things to learn.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Create-a-new-page"><a href="#Create-a-new-page" class="headerlink" title="Create a new page"></a>Create a new page</h3><pre><code class="bash">$ hexo new page aboutme</code></pre><p>More info: <a href="https://hexo.io/docs/commands">Commands | Hexo</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
